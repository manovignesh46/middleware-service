import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  IdType,
  ITopicSubscription,
  IUserDevice,
} from '../../domain/model/user-device.interface';
import { IUserDeviceRepository } from '../../domain/repository/user-device-repository.interface';
import { ISNSService } from '../../domain/services/aws-sns-service.interface';
import { EndpointArnStatus } from './aws-sns.service';
import { DeviceDetailsDTO } from '../controllers/customers/dtos/deviceDetails.dto';
import { UserDevice } from '../entities/user-device.entity';

@Injectable()
export class PushNotificationService {
  private logger = new Logger(PushNotificationService.name);
  private SNS_GENERAL_TOPIC_PUSH_ARN: string;
  constructor(
    private readonly userDeviceRepository: IUserDeviceRepository,
    private readonly snsService: ISNSService,
    private configService: ConfigService,
  ) {
    this.SNS_GENERAL_TOPIC_PUSH_ARN = this.SNS_GENERAL_TOPIC_PUSH_ARN =
      configService.get('SNS_GENERAL_TOPIC_PUSH_ARN');
  }

  /**
   * @description Registers a device for Push Notifications by creating a DB Entry,
      Platform Application Endpoint and Subscribing Endpoint to General Push Notifications Topic.
   *
   * If the entry is already present in the DB with the same deviceId, deviceOs, customerId / leadId
   * then it will not make any changes
   */
  async registerDeviceForPushNotifications(inputDto: {
    deviceId: string;
    firebaseToken: string;
    deviceOs: string;
    customerId?: string;
    leadId?: string;
  }) {
    this.logger.log(this.registerDeviceForPushNotifications.name);
    let idType: IdType;
    let idValue: string;
    const { deviceId, firebaseToken, deviceOs, customerId, leadId } = inputDto;
    if (leadId && !customerId) {
      idType = IdType.LEAD;
      idValue = leadId;
    } else if (customerId) {
      idType = IdType.CUSTOMER;
      idValue = customerId;
    } else if (!leadId && !customerId) {
      throw new Error('Please input either a customerId or leadId value');
    }

    let existingUserDevice =
      await this.userDeviceRepository.findByDeviceIdAndIsActive(deviceId);

    if (
      existingUserDevice &&
      existingUserDevice.deviceId == deviceId &&
      existingUserDevice.firebaseDeviceToken == firebaseToken &&
      existingUserDevice.deviceOs == deviceOs &&
      existingUserDevice.idType == idType &&
      existingUserDevice.customerOrLeadId == idValue &&
      //Endpoint and Topic Subscription present in SNS
      existingUserDevice.platformApplicationEndpoint
    ) {
      this.logger.log(
        `No changes to device properties for user device: ${existingUserDevice.id}`,
      );
      return;
    }
    if (!existingUserDevice) {
      //create a new entry
      const newUserDevice: IUserDevice = {
        customerOrLeadId: idValue,
        idType: idType,
        deviceId: deviceId,
        deviceOs: deviceOs,
        firebaseDeviceToken: firebaseToken,
        platformApplicationEndpoint: undefined,
        subscribedSnsTopics: [],
        isActive: true,
        //Auto-generated by TypeORM below
        id: undefined,
        createdAt: undefined,
        updatedAt: undefined,
      };
      existingUserDevice = await this.userDeviceRepository.createUserDevice(
        newUserDevice,
      );
    } else {
      this.logger.log(`Existing User Device Found: ${existingUserDevice.id}`);
      if (existingUserDevice.firebaseDeviceToken !== firebaseToken) {
        this.logger.log(`Updating firebaseToken for ${existingUserDevice.id}`);
        existingUserDevice.firebaseDeviceToken = firebaseToken; //update firebase token

        //Platform Application Endpoint needs to be updated if Firebase Token Changes
        if (existingUserDevice.platformApplicationEndpoint) {
          const endpointArnStatus = await this.snsService.isValidEndpointArn(
            existingUserDevice.platformApplicationEndpoint,
            firebaseToken,
          );
          if (endpointArnStatus === EndpointArnStatus.NOT_FOUND) {
            //Platform Application Endpoint Does not Exist - To be Created Later
            existingUserDevice.platformApplicationEndpoint = undefined;
          } else {
            this.logger.log(
              `updating platformApplicationEndpoint for ${existingUserDevice.id}`,
            );
            /* 
            Update attributes on Platform Application Endpoint 
            with new Firebase token and set Enabled = 'true' 
            */
            await this.snsService.updateEndpointAttributes(
              existingUserDevice.platformApplicationEndpoint,
              firebaseToken,
            );
            //Assumption: Platform application endpoint value is unchanged from the updateEndpoitnAttributes command
          }
        }
      }
      if (
        existingUserDevice.idType !== idType ||
        existingUserDevice.customerOrLeadId !== idValue
      ) {
        this.logger.log(
          `Updating id Type & Value for ${existingUserDevice.id}`,
        );
        existingUserDevice.idType = idType;
        existingUserDevice.customerOrLeadId = idValue;
      }
      if (existingUserDevice.deviceId !== deviceId) {
        this.logger.log(`Updating deviceId for: ${existingUserDevice.id}`);
        existingUserDevice.deviceId = deviceId;
      }
      if (existingUserDevice.deviceOs !== deviceOs) {
        this.logger.log(`Updating deviceOs for: ${existingUserDevice.id}`);
        existingUserDevice.deviceOs = deviceOs;
      }

      //Save Updates for firebaseToken, platformApplicationEndpoint?, idType, idValue ,deviceId
      await this.userDeviceRepository.updateUserDevice(existingUserDevice);
    }

    //Create PlatformApplication Endpoint if not exists
    if (!existingUserDevice.platformApplicationEndpoint) {
      const newPlatformApplicationEndpoint =
        await this.snsService.createPlatformApplicationEndpoint(firebaseToken);
      console.log(newPlatformApplicationEndpoint);
      existingUserDevice.platformApplicationEndpoint =
        newPlatformApplicationEndpoint;
      await this.userDeviceRepository.updateUserDevice(existingUserDevice);
    }

    //Remove Devices associated with the same customer / lead id
    const devicesById = await this.userDeviceRepository.findAllByIdTypeAndValue(
      idType,
      idValue,
    );
    const differentPlatformEndpointOldDevices = devicesById.filter(
      (device) =>
        device.deviceId !== deviceId &&
        device.platformApplicationEndpoint !==
          existingUserDevice.platformApplicationEndpoint,
    );

    if (differentPlatformEndpointOldDevices.length) {
      this.logger.log(
        `Removing old devices associated with ${idType} ${idValue}: ${differentPlatformEndpointOldDevices.map(
          (device) => device.id,
        )} `,
      );
      //De-register old devices
      for (const device of differentPlatformEndpointOldDevices) {
        await this.removeDeviceFromPushNotifications(device.deviceId);
      }
    }

    //For old devices with same platform application endpoint as new device, only delete DB entry
    const samePlatformEndpointOldDevices = devicesById.filter(
      (device) =>
        device.deviceId !== deviceId &&
        device.platformApplicationEndpoint ===
          existingUserDevice.platformApplicationEndpoint,
    );
    if (samePlatformEndpointOldDevices.length) {
      this.logger.log(
        `Deleting Device entries in DB which have the same platform application endpoint ${existingUserDevice.platformApplicationEndpoint} as the newly created device`,
      );
      for (const device of samePlatformEndpointOldDevices) {
        await this.userDeviceRepository.deleteUserDevice(device);
      }
    }
    return existingUserDevice;
  }

  async updateDeviceForGivenCustomerOrLead(inputDto: {
    deviceId: string;
    firebaseToken: string;
    deviceOs: string;
    customerId?: string;
    leadId?: string;
  }) {
    this.logger.log(this.updateDeviceForGivenCustomerOrLead.name);
    const { deviceId, deviceOs, firebaseToken, customerId, leadId } = inputDto;
    const { idType, idValue }: { idType: IdType; idValue: string } =
      this.getIdTypeAndValue(leadId, customerId);

    const existingUserDevicesFromIdValue =
      await this.userDeviceRepository.findAllByIdTypeAndValue(idType, idValue);

    const existingUserDeviceFromDeviceId =
      await this.userDeviceRepository.findByDeviceIdAndIsActive(deviceId);

    //Edge case when more than 1 device tagged to same idType and idValue
    if (existingUserDevicesFromIdValue?.length > 1) {
      this.logger.warn(
        `There is more than 1 user device for ${idType} ${idValue}`,
      );
      //Delete extra userDevices starting from second entry onwards
      for (const device of existingUserDevicesFromIdValue.slice(1)) {
        this.logger.warn(
          `Unenrolling extra deviceId: ${deviceId} as there is more than 1 device tagged to idType: ${idType} idValue: ${idValue}}`,
        );
        await this.removeDeviceFromPushNotifications(device.deviceId);
      }
    }

    if (existingUserDevicesFromIdValue?.length) {
      if (
        existingUserDeviceFromDeviceId?.id &&
        existingUserDevicesFromIdValue[0]?.id != //Are not the same entry in DB
          existingUserDeviceFromDeviceId?.id
      ) {
        this.logger.log('Removing device with same deviceId');
        //Delete entry with same deviceId
        await this.removeDeviceFromPushNotifications(deviceId);
      }

      if (
        existingUserDevicesFromIdValue[0].deviceId != deviceId ||
        existingUserDevicesFromIdValue[0].deviceOs != deviceOs ||
        existingUserDevicesFromIdValue[0].firebaseDeviceToken != firebaseToken
      ) {
        //Update existing device tagged to customerId / leadId with new deviceId
        //This step is necessary because registerDeviceForPushNotifications searches DB by deviceId only
        await this.userDeviceRepository.updateUserDevice({
          ...existingUserDevicesFromIdValue[0],
          deviceId,
        });
        //Update deviceToken, deviceOs and platformApplicationEndpoint
        await this.registerDeviceForPushNotifications(inputDto);
      }
    }
  }

  private getIdTypeAndValue(leadId: string, customerId: string) {
    let idType: IdType;
    let idValue: string;
    if (leadId && !customerId) {
      idType = IdType.LEAD;
      idValue = leadId;
    } else if (customerId) {
      idType = IdType.CUSTOMER;
      idValue = customerId;
    } else if (!leadId && !customerId) {
      throw new Error('Please input either a customerId or leadId value');
    }
    return { idType, idValue };
  }

  async unenrolAllTopics(userDevice: IUserDevice) {
    this.logger.log(this.unenrolAllTopics.name);

    if (
      userDevice?.subscribedSnsTopics?.length &&
      userDevice.subscribedSnsTopics.length > 0
    ) {
      this.logger.log('Unenrolling from all existing topics');
      //unsubscribe endpoint from any existing topics
      for (const subscription of userDevice.subscribedSnsTopics) {
        this.logger.log(
          `Unenrolling from topic. TopicARN: ${subscription.topicArn} SubscriptionARN: ${subscription.subscriptionArn}`,
        );
        await this.snsService.unsubscribeEndpointFromTopic(
          subscription.subscriptionArn,
        );
      }
      userDevice.subscribedSnsTopics = [];
      await this.userDeviceRepository.updateUserDevice(userDevice);
    }
    return userDevice;
  }

  async enrolTopic(userDevice: IUserDevice, topicArnToAdd?: string) {
    const { topicArn, subscriptionArn } =
      await this.snsService.subscribeEndpointToTopic(
        userDevice.platformApplicationEndpoint,
        topicArnToAdd || this.SNS_GENERAL_TOPIC_PUSH_ARN,
      );

    const addedTopicSubscription: ITopicSubscription = {
      topicArn: topicArn,
      subscriptionArn: subscriptionArn,
      userDeviceUUID: undefined,
      createdAt: undefined,
      updatedAt: undefined,
    };
    userDevice.subscribedSnsTopics.push(addedTopicSubscription);
    await this.userDeviceRepository.updateUserDevice(userDevice);
  }

  async removeDeviceFromPushNotifications(deviceId: string) {
    let deviceToRemove =
      await this.userDeviceRepository.findByDeviceIdAndIsActive(deviceId);
    if (!deviceToRemove) {
      return;
    }
    deviceToRemove = await this.unenrolAllTopics(deviceToRemove);

    if (deviceToRemove.platformApplicationEndpoint) {
      await this.snsService.deleteEndpoint(
        deviceToRemove.platformApplicationEndpoint,
      );
      this.logger.log(
        `Removing User Device: ${deviceToRemove.id} with Device Id: ${deviceToRemove.deviceId}`,
      );
    }
    return this.userDeviceRepository.deleteUserDevice(deviceToRemove);
  }

  async getUserDevice(deviceId: string) {
    return this.userDeviceRepository.findByDeviceIdAndIsActive(deviceId);
  }

  async convertLeadIdToCustomerId(leadId: string, customerId: string) {
    this.logger.log(this.convertLeadIdToCustomerId.name);
    const userDevice = await this.userDeviceRepository.findByLeadIdAndIsActive(
      leadId,
    );
    if (userDevice) {
      userDevice.idType = IdType.CUSTOMER;
      userDevice.customerOrLeadId = customerId;
      return this.userDeviceRepository.updateUserDevice(userDevice);
    }
  }

  async getEndpointArnFromCustomerOrLeadId(
    idType: IdType,
    idValue: string,
  ): Promise<string> {
    if (!idType || !idValue) {
      this.logger.warn('Input a idType and idValue');
      return;
    }
    const userDevices: IUserDevice[] =
      await this.userDeviceRepository.findAllByIdTypeAndValue(idType, idValue);
    if (!userDevices?.length) {
      this.logger.warn(
        `No UserDevice found for idType: ${idType} idValue: ${idValue}`,
      );
      return;
    }
    if (userDevices.length > 1) {
      this.logger.warn(
        `More than one active push notification device for idType: ${idType} idValue: ${idValue}`,
      );
    }
    return userDevices[0]?.platformApplicationEndpoint;
  }

  async registerToken(deviceDetails: DeviceDetailsDTO): Promise<boolean> {
    let existingUserDevice: IUserDevice =
      await this.userDeviceRepository.findByDeviceId(deviceDetails.deviceId);
    if (existingUserDevice) {
      if (
        existingUserDevice.firebaseDeviceToken !== deviceDetails.deviceToken
      ) {
        this.logger.log(`Updating firebaseToken for ${existingUserDevice.id}`);
        existingUserDevice.firebaseDeviceToken = deviceDetails.deviceToken; //update firebase token
        existingUserDevice.deviceOs = deviceDetails.deviceOs;

        //Platform Application Endpoint needs to be updated if Firebase Token Changes
        if (existingUserDevice.platformApplicationEndpoint) {
          const endpointArnStatus = await this.snsService.isValidEndpointArn(
            existingUserDevice.platformApplicationEndpoint,
            deviceDetails.deviceToken,
          );
          if (endpointArnStatus === EndpointArnStatus.NOT_FOUND) {
            //Platform Application Endpoint Does not Exist - To be Created Later
            existingUserDevice.platformApplicationEndpoint = undefined;
          } else {
            this.logger.log(
              `updating platformApplicationEndpoint for ${existingUserDevice.id}`,
            );
            /* 
            Update attributes on Platform Application Endpoint 
            with new Firebase token and set Enabled = 'true' 
            */
            await this.snsService.updateEndpointAttributes(
              existingUserDevice.platformApplicationEndpoint,
              deviceDetails.deviceToken,
            );
            //Assumption: Platform application endpoint value is unchanged from the updateEndpoitnAttributes command
          }
        }
        this.userDeviceRepository.updateUserDevice(existingUserDevice);
      }
    } else {
      existingUserDevice = new UserDevice();
      existingUserDevice.deviceId = deviceDetails.deviceId;
      existingUserDevice.deviceOs = deviceDetails.deviceOs;
      existingUserDevice.firebaseDeviceToken = deviceDetails.deviceToken;
      existingUserDevice.isActive = true;
      this.userDeviceRepository.createUserDevice(existingUserDevice);
    }
    return true;
  }
}
